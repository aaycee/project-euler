/** Akachukwu Obi, 2018

Project Euler #12 - Highly divisible triangle number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms in the sequence would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

What is the value of the first triangle number to have over five hundred divisors?

Retrieved 25 June 2018 from https://projecteuler.net/problem=12
**/


// code to generate a set of n triangle numbers: first successful try
function triNumOfLengthN(n) {
    "use strict";
    var set, i;
    set = [];
    for (i = 1; i <= n; i = i + 1) {
        set.push(i * (i + 1) / 2); // the calculation algorithm i*(i+1)/2 was retrieved from wikipedia
    }
    return set;
}
// test
triNumOfLengthN(7);
// --> [1, 3, 6, 10, 15, 21, 28]


// code to generate a set of n triangle numbers: second successful try
var triNumOfLengN = function (n) {
    "use strict";
    var set, i;
    set = [1]; // I added the first element to the set so that 'set[i-1]' in the for loop below is valid
    for (i = 1; i < n; i = i + 1) {
        set.push(i + 1 + set[i - 1]); // this takes the simple idea of adding a number (or set position) to the sum of the natural numbers before it
    }
    return set;
};
// test
triNumOfLengN(7);
// --> [1, 3, 6, 10, 15, 21, 28]

// code to generate a set of n triangle numbers: third successful try (similar to second try)
var triNumOfLenN = function (n) {
    'use strict';
    var set, x, y;
    set = [];
    x = 0;
    y = 1;
    while (set.length < n) {
        x += y;
        set.push(x);
        y += 1;
    }
    return set;
};
// test
triNumOfLenN(7);
// --> [1, 3, 6, 10, 15, 21, 28]

// code to calculate factors of any number: first successful try
var factorsOf = function (n) {
    "use strict";
    var factorset, i;
    factorset = [];
    for (i = 1; i <= n; i = i + 1) {
        if (n % i === 0) {
            factorset.push(i);
        }
    }
    return factorset;
};
// test
factorsOf(18);
// --> [1, 2, 3, 6, 9, 18]

// code to calculate factors of any number: second successful try adapted from briguy37 https://jsfiddle.net/briguy37/FSC3c/
function getFactors(number){
    var factors, possibleFactor, sqrt;
    factors = [];
    possibleFactor = 1;
    sqrt = Math.sqrt(number); // reduce # of iterations
    while(possibleFactor <= sqrt){ // avoid repeating factors
        if(number % possibleFactor === 0){ 
            factors[factors.length] = possibleFactor; // could use factors.push(possibleFactor) as well
            
            var otherPossibleFactor = number / possibleFactor; // this is guaranteed to be whole number factor
            if(otherPossibleFactor !== possibleFactor){ // otherPossibleFactor > possibleFactor also works
                factors[factors.length] = otherPossibleFactor;
            } 
        }
        possibleFactor++;
    }
    
    return factors; // unsorted
    // return factors.sort((a, b) => a - b); // sorted
}
// test
getFactors(35);
// --> [1, 35, 5, 7]

// code to find the first natural number with over n factors: first successful try
var facLength = function (number) {
    "use strict";
    var factorset, i, n;
    factorset = [];
    n = 1;
    while (factorset.length <= number) {
        factorset = []; // resets the factorset after each loop to avoid concatenating different sets 
        for (i = 1; i <= n; i = i + 1) { // classic forloop to create a factorset
            if (n % i === 0) {
                factorset.push(i);
            }
        }
        n = n + 1;
    } // btw, this seems like a recipe for disaster. A for loop and an if statement nested within a while loop
    return factorset;
};
// test
facLength(500);
// facLength(500) was too big to start with. It is better to examine trends with smaller facLength numbers 
// while this function is a bit annoying, I promised to strive-on before consulting uncle Google. It also helps my discipline that I'm currently in a house without wifi at the moment.
// I could try using higher order functions or OOP to see if I can't shorten the execution time


// code to check factorset of an array
var triFac = function (n) { // n is the position of the triangle number and not the triangle number
    'use strict';
    var triNum, factorset, i;
    triNum = n * (n + 1) / 2;
    factorset = [];
    for (i = 1; i <= triNum; i = i + 1) {
        if (triNum % i === 0) {
            factorset.push(i);
        }
    }
    // return "The " + n + "th triangle number is " + triNum + " and has a set of " + factorset.length + " factors " + factorset;
    return factorset.length;
};
// test
triFac(500);
// --> 32


// code to check the first triangle number with over n factors.
var triFacLen = function (len) {
    'use strict';
    var triNum, factorset, possibleFactor, n;
    n = 1; // n is the position of the triangle number
    // triNum = n * (n + 1) / 2;
    factorset = [];
    while (factorset.length <= len) {
        factorset = []; // resets the factorset after each loop to avoid concatenating different sets 
        n = n + 1;
        triNum = n * (n + 1) / 2; // algorithm to calculate the nth triangle number

        for (possibleFactor = 1; possibleFactor <= triNum; possibleFactor += 1) { // classic forloop to create a factorset
            if (triNum % possibleFactor === 0) {
                factorset.push(possibleFactor);
            }
        }
    }
    // return triNum + ": " + factorset;
    return triNum + " (" + factorset.length + " factors): " + factorset;
    // return "The first triangle number with over " + len + " divisors is " + triNum + " with " + factorset.length + " divisors: " + factorset;
};
// test
triFacLen(10);
// --> "120 (16 factors): 1,2,3,4,5,6,8,10,12,15,20,24,30,40,60,120"
// triFacLen(500); --> "76576599 (576 factors): {set of 576 factors}"
// while triFacLen(500) is doable, we run into the same problem with overuse of forloops. It'd take so much time and computing power. 20 or so hours later, I've finally earned my Google solution.
// by the way, 76576599 is wrong; 76576500 is correct.


// With a tiny bit of modification, I exponentially shortened my calculation time

// code to check the first triangle number with over n factors: second and final try
var triFacLength = function (len) {
    'use strict';
    var triNum, factorset, possibleFactor, sqrt, otherFactor, n;
    n = 1; // n is the position of the triangle number
    // triNum = n * (n + 1) / 2;
    factorset = [];
    while (factorset.length <= len) {
        factorset = []; // resets the factorset after each loop to avoid concatenating different sets 
        n = n + 1;
        triNum = n * (n + 1) / 2; // algorithm to calculate the nth triangle number
        sqrt = Math.sqrt(triNum);
        for (possibleFactor = 1; possibleFactor <= sqrt; possibleFactor += 1) { // classic forloop to create a factorset
            if (triNum % possibleFactor === 0) {
                factorset.push(possibleFactor);
                
                otherFactor = triNum / possibleFactor;
                if (otherFactor !== possibleFactor) {
                    factorset.push(otherFactor);
                    }
            }
        }
    }
    // return triNum + ": " + factorset;
    return triNum + " (" + factorset.length + " factors): " + factorset.sort((a, b) => a - b); 
};
// test
triFacLength(500);
// --> "76576500 (576 factors): [set of 576 factors]"